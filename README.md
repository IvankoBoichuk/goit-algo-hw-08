### Алгоритм
1. Розміщуємо довжини всіх кабелів у мін-купу. У Python для цього можна скористатись модулем `heapq`.
2. Ініціюємо змінну `total_cost` для накопичення загальних витрат.
3. Поки в купі більше одного кабелю:
   - Виймаємо два найкоротші елементи з купи (тобто дві мінімальні довжини).
   - Обчислюємо вартість їх об’єднання та додаємо її до `total_cost`.
   - Додаємо новий об'єднаний кабель назад у купу.
4. Після завершення процесу в `total_cost` буде збережено мінімальні загальні витрати.

### Пояснення коду
- `heapq.heapify(cables)` перетворює список `cables` у мін-купу.
- `heapq.heappop(cables)` дістає найменший елемент із купи, а `heapq.heappush(cables, cost)` додає елемент назад.
- На кожному кроці ми додаємо вартість об'єднання двох кабелів до `total_cost`.
- Коли в купі залишиться один кабель, `total_cost` міститиме мінімальні можливі загальні витрати.

### Приклад
Припустимо, що маємо кабелі з довжинами `[4, 3, 2, 6]`.

1. Перший крок: об’єднуємо кабелі довжиною `2` і `3`, витрати `2 + 3 = 5`.
2. Додаємо `5` назад у купу. Тепер у нас `[4, 5, 6]`.
3. Об’єднуємо `4` і `5`, витрати `4 + 5 = 9`.
4. Додаємо `9` назад у купу. Тепер у нас `[6, 9]`.
5. Об’єднуємо `6` і `9`, витрати `6 + 9 = 15`.

Загальна вартість: `5 + 9 + 15 = 29`.

### Складність
- **Часова складність:** \(O(n \log n)\), де \(n\) — кількість кабелів.
